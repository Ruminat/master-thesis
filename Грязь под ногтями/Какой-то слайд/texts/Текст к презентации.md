# Текст к презентации

### 1. Титульник

Добрый день, меня зовут Фурман Владислав Константинович, мой научный руководитель — Сабинин Олег Юрьевич. Тема моей работы — «Разработка и исследование системы трансляции запросов на русском языке в SQL-код».

### -1/12. Цель и задачи работы

Крч тупа зачитаю, шо на слайде.

### 2. Мотивация

Итак, зачем же может понадобиться система трансляции из русского языка в SQL. В наши дни информация довольно часто хранится в базах данных, работать с которой можно при помощи языка SQL, однако знают его далеко не все. При этом существуют также различные диалекты в различных СУБД и код, работающий, скажем в Oracle, в MySQL уже может и не работать. Нужно также иметь хоть какое-то представление о том, как устроены базы данных и как работают СУБД ими управляющие.

Более того, часто, на естественном языке запрос можно написать гораздо проще и быстрее.

Для английского языка существует множество исследований и решений, как платных, так и бесплатных, что может говорить о высокой актуальности проблемы. На русском же языке готовых решений как таковых нет. 

### 3. Подходы к трансляции

Как можно подойти к решению проблемы трансляции? На сегодняшний день выделяют 2 подхода:

1. Сементический парсинг, здесь вы пишете некий алгоритм формализации запросов, иными словами, пишете какого-либо рода парсер, после чего на основе формальной модели строите SQL-запрос.
2. Второй подход — это нейронные сети. Все открытые англоязычные решения используют нейронные сети, однако для русского языка поступить подобным образом довольно проблематично — для этого требуется довольно обширный корпус вручную размеченных запросов, датасет WikiSQL, к примеру, содержит 80 000 запросов, что одному человеку реализовать попросту не под силу. Поэтому в данной работе выбор был сделан в пользу сементического парсинга.

### 4. Абстрактные регулярные выражения

Как происходит формализация запроса в моей работе? Я решил попробовать обобщить идею о регулярных выражениях и разработал Абстрактные регулярные выражения, основаны они на недетерминированных конечных автоматах. В отличие от обычных регулярных выражений, которые работают только со строками, они могут работать с объектами любой природы, в данной работе — это, например, токены, — и предикаты тоже могут быть любыми, в обычных же регулярных выражениях можно проверить символ на равенство другому символу или на принадлежность множеству символов.

Но это не самое главное, основное их отличие в том, что при поиске абстрактные регулярные выражения сохраняют структуру шаблона, то есть, находя, скажем, условие выборки, вам вернётся не всё условие целиком, а его структура: отдельные столбцы, оператор сравнения и т.д.

Абстрактные регулярные выражения позволяют писать шаблоны в декларативном стиле, то есть все шаблоны будут храниться в одном месте и добавить новый шаблон или изменить существующий довольно просто. Более того, при написании базового набора шаблонов, в большинстве случаев вносить изменения в шаблоны можно будет без изменения кода обработки этих шаблонов.

Внизу слайда можно увидеть пример конечного автомата, конечные автоматы представляют собой набор состояний и переходы между ними (предикаты и другие шаблоны). Предикатом, к примеру, является условие «является ли токен таблицей» или «является ли он затятой или союзом И» (это connector). 

### 5. Примеры шаблонов

Рассмотрим пример шаблона для секции `SELECT`.

- `selectExpr` состоит из списка столбцов или таблицы.
- `listOfColumns` список столбцов, в конце которого может стоять таблица для указания, что столбцы принадлежат ей.
- `columnExpr` — столбцовое выражение, состоит из столбца и из 0 или более операторов.
- `connector` — запятая или союиз И.

Рассмотрим запрос «имя и средняя зарплата сотрудников». Описываю картинку.

### 6. Этапы обработки запроса

Как обрабатывается запрос:

- Сначала идёт токенизация, то есть мы разбиваем наш запрос на слова, числа, кавычки, точки и т.д.
- Далее идёт морфология, нахождение лемм с помощью библиотеки MyStem. Лемма — это начальная форма слова, например, у слова «сотрудников» лемма «сотрудник».
- Потом мы сопоставляем это с шаблонами, получаем структуру запроса.
- После чего мы избавляемся от шаблонов, приводя нашу структуру к JSON-объекту уже почти готового запроса без привязки к какой-либо СУБД.
- И, наконец, транслируем в SQL-код для заданной СУБД (в данной работе реализована СУБД Oracle).

### 7. Архитектура системы

Из чего состоит реализованная система:

- Клиентское настольное приложение, написанное на JavaScript с использованием фреймворка Electron.
- Сервер на Python с фреймворком Falcon.
- База данных Oracle.

Пользователь делает запрос на русском языке, запрос отправляется на сервер, на сервере он транслируется в SQL-код, после чего передаётся базе данных на выполнение, результат возвращаетя пользователю.

### 8. Клиентское приложение

Вот так выглядит клиентское приложение, является оно подобием чата, в котором вы задаёте вопросы, а база даза данных на них отвечает.

### 9. Сервер (транслятор)

Читаю со слайда.

### 10. Синонимы объектов. Пример запроса

Для работы транслятора нужно задать синонимы названий таблиц и столбцов на русском языке. К примеру для таблицы Employees можно добавить синонимы сотрудники, работники, служащие. На слайде представлен запрос и SQL-код, сгенерированный для него системой.

### 11. Запрос с соединением таблиц

Для всех таблиц автоматически вычисляются минимальные пути до других таблиц. Рассмотрим, например, такой запрос: «Имя, фамилия работника и страна». Заметим, что столбцы имя и фамилия принадлежат таблице Employees, их нужно соединить с таблицей countries. Для этого мы ищем путь из таблицы Employees до Countries. Сгенерированный код представлен на слайде.

### 12. Различные формулировки запроса

Позиция и порядок ключевых слов в запросе не так важны, запрос может также содержать не имеющие смысловой нагрузки слова, важно лишь то, что ключевые части запроса (каждое отдельное условие, каждый отдельный столбец и т.д.) будут сопоставлены с шаблонами.

Рассмотрим две формулировки одного запроса:

(читаю запросы со слайда)

во втором запросе мы поменяли местами секции SELECT и ORDER BY, использовали другие слова для столбцов (например, использовали заработок и оклад вместо зарплаты), добавили несколько не несущих смысловой нагрузки слов (причём, вывести нужно).

Сгенерированный код для обоих запросов идентичен. Причём заметим, что в условии неявно для пользователя используеются TRIM и LOWER для менее строго поиска.

### 13. `WHERE` и `HAVING`. Группировка

В SQL есть два вида условий: WHERE и HAVING. Первое используется для фильтрации данных, второе же — для фильтрации групп, создаваемых GROUP BY. В какую секцию добавить условие определяется наличием или отсутствием агрегатной функции, в данном случае — MIN.

(читаю запрос со слайда)

### 14. Заключение

Подведём итоги. (читаю со слайда).

Хотелось бы поговорить а минусах и потенциале подхода.

— При текущем подходе довольно сложно, а в некоторых случаях,  наверное, и невозможно, реализовать обработку разрозненных данных (если, например, в начале запроса требуют вывести зарплату сотрудника, а уже  где-то в конце упоминается, что эта зарплата должна быть округлена);  крайне затруднительно также обрабатывать местоимения и глаголы в роли условий, например: «каждого менеджера, имеющего подчинённых».

—  Сделать с текущим подходом можно ещё много чего: например, можно добавить шаблонов по типу «предскажи доход на следующий  месяц», которые будут, скажем, при помощи линейной регрессии или решающих деревьев предсказывать значение столбца «доход» для следующего  месяца.

Добавить побольше функций (делается это очень просто — нужно просто дополнить соответствующий шаблон, причём код обработки менять не нужно) или можно сделать шаблоны менее строгими добавлением в них слов, не несущих смысловой нагрузки (по типу «вывести зарплату ***всех\*** сотрудников»  или  «зарплату ***у\*** сотрудников» и т.д.), причём опять же, код обработки при этом менять не потребуется, так как эти слова будут попросту проигнорированы при обработке.